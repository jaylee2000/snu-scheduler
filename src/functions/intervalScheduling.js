const mongoose = require("mongoose");
const { Subject } = require("../models/subject");
const { Restriction } = require("../models/restriction");
const { MustTakeGroup } = require("../models/mustTakeGroup");
const { daysOfWeek, mondayToFriday } = require("../definitions/arrays");
const { calculateSafetyZone } = require("./calculateSafetyZone");

function sortByWeight(candidateScheduleA, candidateScheduleB) {
    return -candidateScheduleA.weightSum + candidateScheduleB.weightSum;
}

function doesOverlap(class_i, class_j) {
    for (let day of mondayToFriday) {
        for (let i = 0; i < class_i[day].length; i++) {
            for (let j = 0; j < class_j[day].length; j++) {
                let start1 = class_i[day][i][0];
                let end1 = class_i[day][i][1];
                let start2 = class_j[day][j][0];
                let end2 = class_j[day][j][1];
                if (start1 > 0 && start2 > 0) { // Both subjects run on this day-of-week
                    if (end1 > start2 && end2 > start1) { // The two subjects overlap
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

async function satisfyGroupConditions(selectedClasses) {
    const allGroups = await MustTakeGroup.find({});
    for (let group of allGroups) {
        let cntClasses = 0;
        for (let memberSubject of group.members) {
            if (
                selectedClasses.some(
                    (e) => e._id.toString() === memberSubject.toString()
                )
            ) {
                cntClasses++;
            }
        }
        if (
            group.minSelection > cntClasses ||
            cntClasses > group.maxSelection
        ) {
            return false;
        }
    }
    return true;
}

async function isPossibleCombination(selectedClasses) {
    for (let i = 0; i < selectedClasses.length; i++) {
        for (let j = i + 1; j < selectedClasses.length; j++) {
            if (doesOverlap(selectedClasses[i], selectedClasses[j])) {
                return false;
            }
            if (
                selectedClasses[i].subjectName ===
                selectedClasses[j].subjectName
            ) {
                return false;
            }
        }
    }

    if (!(await satisfyGroupConditions(selectedClasses))) {
        return false;
    }
    return true;
}

function getSum(selectedClasses, property) {
	return selectedClasses.reduce(function(a, b) {
		return a + b[property];
	}, 0)
}

async function schedulize(possibleClasses, selectedIndices) {
    const selectedClasses = [];
    for (let i = 0; i < selectedIndices.length; i++) {
        if (selectedIndices[i]) {
            selectedClasses.push(possibleClasses[i]);
        }
    }
    if (await isPossibleCombination(selectedClasses)) {
        const weightSum= getSum(selectedClasses, 'weight');
		const creditSum = getSum(selectedClasses, 'credit');
		return { selectedClasses, weightSum, creditSum };
    } else {
        return undefined;
    }
}


async function generatePossibleSchedules(
    candidates,
    possibleCombinations,
    maxCredit
) {
    const possibleSchedules = [];
    for (let i = 0; i < possibleCombinations.length; i++) {
        const candidateSchedule = await schedulize(
            candidates,
            possibleCombinations[i]
        );
        if (candidateSchedule && candidateSchedule.selectedClasses.length) { // discard schedule generated by seed [0, 0, 0, ..., 0]
            if (candidateSchedule.creditSum <= maxCredit) {
                possibleSchedules.push(candidateSchedule);
            }
        }
    }

    // sort possibleSchedules by weight sum (in descending order)
    possibleSchedules.sort(sortByWeight);
    return possibleSchedules;
}

/*******************************************************************************************************/
/*********************************************** Seeding ***********************************************/
// Given seed: [ [0], [0, 1], [0, 1], [1] ],
// Generates: [ [0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1] ]
// https://stackoverflow.com/questions/12152409/find-all-combinations-of-options-in-a-loop
const cartesian = (...a) =>
    a.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, e].flat())));

function doesOneBlockFitIn(oneTimeBlock, safeTimeBlocks) {
	if(!safeTimeBlocks.length) return false;
	
    const start = oneTimeBlock[0];
    const end = oneTimeBlock[1];
    for (let block of safeTimeBlocks) {
        if (block[0] <= start && end <= block[1]) {
            return true;
        }
    }
    return false;
}

function doesFit(subject, safetyZone) {
	 for (let i = 0; i < mondayToFriday.length; i++) {
        const subjectTimeBlocks = subject[mondayToFriday[i]];
        const safeTimeBlocks = safetyZone[i]; // this has length 0 --> return true
		 
        for (let j = 0; j < subjectTimeBlocks.length; j++) {
            if (!doesOneBlockFitIn(subjectTimeBlocks[j], safeTimeBlocks)) {
                return false;
            }
        }
    }
    return true;
}

function generateSeed(candidates, safetyZone) {
	// Generates seed in form of: [ [0], [0, 1], [0, 1], [1], [0, 1], [1] ]
    // Exclude seeds that didn't include mustTake-courses
    // Exclude seeds that overlap with 'SafetyZone'
    const seed = [];
    for (let i = 0; i < candidates.length; i++) {
        if (candidates[i].mustTake) {
            if (!doesFit(candidates[i], safetyZone)) {
                return [];
            }
            seed.push([1]);
        } else if (!doesFit(candidates[i], safetyZone)) {
            seed.push([0]);
        } else {
            seed.push([0, 1]);
        }
    }
    return seed;
}
/*********************************************** Seeding ***********************************************/
/*******************************************************************************************************/


async function calculateMaxIntervalSum(maxCredit, userId) {
    const candidates = await Subject.find({owner: userId});
    const safetyZone = await calculateSafetyZone(userId);

    if (!candidates || !candidates.length) {
        return [];
    }

    // Exclude seeds that didn't include mustTake-courses
    // Exclude seeds that overlap with 'SafetyZone'
    const cartesianSeed = generateSeed(candidates, safetyZone); // Buggy
	
	if(!cartesianSeed || !cartesianSeed.length) {
		return [];
	}
    const possibleCombinations = cartesian(...cartesianSeed);
	
	
	// In case there is only one subject... just a quick bandage
	if(typeof(possibleCombinations[0]) === "number") {
		if(possibleCombinations.length === 1) {
			return await generatePossibleSchedules(
				candidates,
				[possibleCombinations],
				maxCredit
			);
		}
		else if(possibleCombinations.length === 2) {
			return await generatePossibleSchedules(
				candidates,
				[ [ possibleCombinations[0] ], [ possibleCombinations[1] ] ],
				maxCredit
			);
		}
		
	}

    // Exclude schedules that don't satisfy mustTakeGroup restrictions
    // Exclude schedules whose credit sum exceeds maxCredit
    // Sort by weight in descending order
    return await generatePossibleSchedules(
        candidates,
        possibleCombinations,
        maxCredit
    );
}

module.exports = {
    calculateMaxIntervalSum,
    isPossibleCombination,
    schedulize,
    doesFit,
};
